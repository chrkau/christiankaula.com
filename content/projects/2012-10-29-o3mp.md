title: o3mp
slug: o3mp
date: 2012-10-29 15:40
tags: o3mp, websockets, html5

XMPP is great. Actually I am a big fan. I even run my own server. Yet there are a few areas where I feel Jabber is lacking or stuff could be done better. That is why I developed the basics for a protocol that does things the Right Way™. Because I like stuff that rhymes I called it o3mp. But if you ask me directly I will lie and tell you it stands for "Open Object Oriented Messaging Protocol".



## Basic assumptions

When I set out to specify o3mp I assumed the following:

* XMPP gets a whole bunch of things right.
* People are using multiple devices – often simultaneously – to communicate.
* Any device that matters comes with a halfway decent browser built in.
* Nobody likes XML.
* Only distributed communication systems can be truly free.

So this means we are talking about a protocol that should work natively in the browser. There are only two native data formats in the browser: XML and JSON. As XML is out by default this leaves us with JSON. And WebSockets seems a pretty obvious choice when one hears *real time* in conjunction with *browser*.



## Everything is a JSON object

Now that we know that JSON is our data exchange format let's go all the way: Everything is a JSON object. Furthermore every object inherits from a abstract base type called o3mp Object or shorter o3O. To know of what type exactly a o3O is every object has a *type* attribute. This leaves us with an idea of a basic o3O that looks something like this:


	:::JSON
	{
		"type": ["some", "type"],
		"node": "example.org"
	}



## If it's not permanent it's sendable

There will have to be two basic types of o3Os:

* Permanent o3Os that store data permanently.
* Sendable o3Os that can be exchanged to describe and manipulate permanent o3Os.


### Permanents

All permanent o3Os – from now on *Permanent* – will have to have some basic meta information about by whom they were created, when that happened, when they were last updated. Every Permanent will also have to have the information about its origin as we are talking about a decentralized protocol – let's say the smallest unit of origin is called a node. And of course every permanent object needs to have a globally unique ID.

A basic Permanent could look like this:

	:::JSON
	{
		"type": ["some", "permanent"],
		"node": "example.org",
		"id": "a1b2c3",
		"creator": ["some", "creator"],
		"created": "2012-12-31T12:55:13Z",
		"updated": "2012-12-31T13:15:22Z"
	}

Permanents will have to live on the server side as we said users are going to use multiple devices and we need to make sure everything is available on every device.

Oh, and there is a special case: There have to be Permanents that represent those entities that actually consume data over the protocol. Let's call those *Transceivers*.


### Sendables

Now to somehow exchange Permanents we need another type of o3O that can be sent over the wire. Let's call those Sendables. They will have these tasks:

* Request creation, update, deletion or delivery of Permanents.
* Responding to Requests.
* Let the client know when/why a critical error occurred.


#### Requests/Responses

To do CrUD stuff or fetch Permanents we will need a Sendable type *Request* which will always have to be followed up with a *Response* from the other side. That way we will know if a Request was actually processed and what its result was. To map Responses to Requests there will have to be a *Request ID* that identifies exactly one Request/Response pair in the current connection.

Applying all of this we end up with the following as a bare bone Request:

	:::JSON
	{
		"type": ["req", "asubtype"],
		"node": "example.org",
		"rid": 123
	}

While a minimal Response could look like this:

	:::JSON
	{
		"type": ["resp", "asubtype"],
		"node": "example.org",
		"rid": 123
	}


#### Errors

Now the other task of Sendables is to enable the server to let the client now how something went wrong before it closes the connection. These o3Os could be called… well how about *Errors*.

The minimal example:

	:::JSON
	{
		"type": ["error", "someerror"],
		"desc": "A server side error has occured."
	}



## Base Types



Permanents

Meta (Permanent)
: Meta o3Os are objects that only exist to describe things concerning o3mp itself. Connections and nodes would be subtypes of this.

Message (Permanent)
: Messages are chunks of information that are exchanged between Transceivers. Examples could include instant messages or posts.

Relation (Permanent)
: Relations represent the information that binds two Permanent o3Os together. Examples could include subscriptions, ACLs and chat presence.

Channel (Transceiver)
: A Channel is an object that acts as a container for Messages. Examples could include chat rooms or micro blogging streams.

Identity (Transceiver)
: Identities represent entities


User (Identity)
: Represents an actual user.


Sendables

Request
:

Response
:

Error
: blub



## Status



## What is missing


